<!-- ğŸ”— Custom Stylesheet -->
<link rel="stylesheet" href="../../_css/main.css">

<!-- ğŸ–¼ï¸ Site Logo -->
![Site Logo](/_pix/logos/logo-ehw-kb-h32.png)


<!-- ğŸ“ Title -->
# ğŸ“’ COURSE NOTES: <span class="course-title">[Learn to Code in Python](https://www.boot.dev/lessons/78b4646f-85aa-42c7-ba46-faec2f0902a9)</span>

## ğŸ“‚ Chapter 08: **Loops**

* **Chapter URL:** https://www.boot.dev/lessons/81ebc973-32c2-40d3-92a0-97c594bff0ba


<!-- ğŸ§­ Navigation -->
### [ğŸšï¸ README](../../README.md) | [ğŸ“ Index](index.md) | [ğŸ”– Bookmark](#bookmark)

<span class="warning-banner">IN-PROGRESS: 2025-10-30</span>


<br>

**In this Chapter:**  

<section class="ehw-doc-descr">  

### Learn to Code in Python, Ch. 05: *Testing and Debuging*

These are my personal notes on **<MAIN_TOPIC_LIST>** from Boot.dev. This chapter teaches how to <write 2-3 concise sentences summarizing what the chapter teaches and why it matters in real-world contexts, and clearly showing important bolded concepts and terms>.<end with the single-line real-world application / benefits sentence included at least 3 bolded real-world application phrases (e.g., medical software, debugging complex decision trees, gaming sofware, database management, livestreaming applications, industrial (PLC) logic controls, robotics, roomba robot vaccuums, etc.)>.   

### Learning Outcomes  

By the end of this chapter, I should be able to:  

- <Outcome 1 â€“ actionable and measurable>
- <Outcome 2 â€“ applying in different contexts>
- <Outcome 3 â€“ debugging or preventing common issues>
- <Outcome 4 â€“ explaining clearly>
- <Outcome 5 â€“ executing essential workflows>

</section>

### Applied Examples

| #ï¸âƒ£   | Example | Details |
| --- | ------- | ------- |
| 1   | --      | -       |
| 2   | --      | -       |
| 3   | --      | -       |

<!-- ğŸ·ï¸ RELATED TAGS -->
<section id="sec-tags">

## ğŸ·ï¸ Tags:

- Python
- Loops
- Whitespace
- Range
- While
- Continue
- Break


</section>

---


<!-- ğŸ“– TOC (Table of Content) -->
<details open>

<summary>Table of Contents</summary>

- [ğŸ“’ COURSE NOTES: Learn to Code in Python](#-course-notes-learn-to-code-in-python)
  - [ğŸ“‚ Chapter 08: **Loops**](#-chapter-08-loops)
    - [ğŸšï¸ README | ğŸ“ Index | ğŸ”– Bookmark](#ï¸-readme---index---bookmark)
    - [Learn to Code in Python, Ch. 05: *Testing and Debuging*](#learn-to-code-in-python-ch-05-testing-and-debuging)
    - [Learning Outcomes](#learning-outcomes)
    - [Applied Examples](#applied-examples)
  - [ğŸ·ï¸ Tags:](#ï¸-tags)
    - [â–¶ï¸ L1: Loops](#ï¸-l1-loops)
- [Loops](#loops)
  - [Whitespace Matters in Python!](#whitespace-matters-in-python)
  - [Assignment](#assignment)
    - [â–¶ï¸ L2: Loops Practice](#ï¸-l2-loops-practice)
    - [â–¶ï¸ L3: Loops Practice](#ï¸-l3-loops-practice)
  - [Assignment](#assignment-1)
    - [â–¶ï¸ L4: Loop Review](#ï¸-l4-loop-review)
    - [â–¶ï¸ L5: Loop Review](#ï¸-l5-loop-review)
    - [â–¶ï¸ L6: Whitespace in Python](#ï¸-l6-whitespace-in-python)
    - [â–¶ï¸ L7: Range Continued](#ï¸-l7-range-continued)
  - [Assignment](#assignment-2)
  - [Tip](#tip)
    - [â–¶ï¸ L8: Sum Game](#ï¸-l8-sum-game)
  - [Assignment](#assignment-3)
    - [â–¶ï¸ L9: Sum Game 2](#ï¸-l9-sum-game-2)
  - [Assignment](#assignment-4)
  - [Tips](#tips)
  - [Frequently Asked Questions](#frequently-asked-questions)
        - [What are the Training Grounds?](#what-are-the-training-grounds)
        - [How are the challenges generated?](#how-are-the-challenges-generated)
        - [How do custom instructions work?](#how-do-custom-instructions-work)
        - [How do the game-mechanics work?](#how-do-the-game-mechanics-work)
        - [What if the challenges are bad?](#what-if-the-challenges-are-bad)
  - [CORRECT! ğŸ†](#correct-)
    - [â–¶ï¸ L10: While](#ï¸-l10-while)
  - [Assignment](#assignment-5)
  - [Tip](#tip-1)
    - [â–¶ï¸ L11: Continue Statement](#ï¸-l11-continue-statement)
  - [Avoiding Work](#avoiding-work)
  - [Assignment](#assignment-6)
    - [â–¶ï¸ L12: Break Statement](#ï¸-l12-break-statement)
    - [â–¶ï¸ L13: Match Countdown](#ï¸-l13-match-countdown)
    - [â–¶ï¸ L14: Experience Points](#ï¸-l14-experience-points)
    - [â–¶ï¸ L15: Meditate](#ï¸-l15-meditate)
  - [References](#references)


</details>
<!-- Lesson Notes -->


### â–¶ï¸ L1: Loops


<section class="callout"><span class="label-verbatim">COPIED VERBATIM:  ğŸ‘‡ğŸ½</span>

# Loops

Loops are a programmer's best friend. Loops allow us to do the same operation multiple times without having to write it explicitly each time.

For example, let's pretend I want to print the numbers 0-9.

I could do this:

```py
print(0)
print(1)
print(2)
print(3)
print(4)
print(5)
print(6)
print(7)
print(8)
print(9)
```

Even so, it would save me a lot of time typing to use a _loop_. Especially if I wanted to do the same thing _one thousand_ or _one million_ times.

A _"for loop"_ in Python is written like this:

```py
for i in range(0, 10):
    print(i)
```

`i` replaces the numbers `0` to `9`. In English, the code says:

1.  Start with `i` equals `0`. (`i in range(0)`)
2.  If `i` is not less than 10 (`range(0, 10)`), exit the loop. Else:
    *   Print `i` to the console. (`print(i)`)
    *   Add `1` to `i`. (`range` defaults to incrementing by 1)
    *   Go back to step `2`.

The result is that the numbers `0-9` are logged to the console in order.

> â„¹ï¸ The numbers `a`, `b` in `range(a, b)` are _inclusive_ of `a` and _exclusive_ of `b`.  
So `range(0, 10)` includes `0` but not `10`.

![](https://storage.googleapis.com/qvault-webapp-dynamic-assets/course_assets/yWuHPsL-600x353.png)

## Whitespace Matters in Python!

> â„¹ï¸ The body of a for-loop _must_ be indented, otherwise you'll get a syntax error.


</section>

<section class="callout"><span class="label-verbatim">Assignment:  ğŸ‘‡ğŸ½</span>

## Assignment

Complete the missing sections of the for-loop in the `print_numbers` function so that it prints the numbers 0-99 to the console.


</section>

<br>

<section class="assignment-answer-sec">

**âœï¸ ASSIGNMENT STARTING CODE:**

<span class="code-filename">main.py</span>

```py
def print_numbers():
    for :
        print(i)


# Don't edit below this line


def test():
    print("Printing numbers from 0 to 99:")
    print_numbers()
    print("=====================================")


def main():
    test()


main()
```

**âœï¸ MY ANSWER:**

```py
def print_numbers():
    for i in range(0,100):
        print(i)


# Don't edit below this line


def test():
    print("Printing numbers from 0 to 99:")
    print_numbers()
    print("=====================================")


def main():
    test()


main()
```

</section><!-- END .assignment-answer-sec -->



### â–¶ï¸ L2: Loops Practice



### â–¶ï¸ L3: Loops Practice

<section class="callout"><span class="label-verbatim">Assignment:  ğŸ‘‡ğŸ½</span>

## Assignment

In the `print_numbers_from_five_to` function, the for-loop starts at `0`. It should start at `5`. Only change the start.

</section>

<br>

<section class="assignment-answer-sec">

**âœï¸ ASSIGNMENT STARTING CODE:**

<span class="code-filename">main.py</span>

```py
def print_numbers_from_five_to(end):
    for i in range(0, end):
        print(i)


# Don't edit below this line


def test(end):
    print(f"Using input end: {end}")
    print(f"Printing numbers from 5 to {end - 1}:")
    print_numbers_from_five_to(end)
    print("=====================================")


def main():
    test(16)
    test(6)
    test(11)


main()
```

**âœï¸ MY ANSWER:**

```py
def print_numbers_from_five_to(end):
    for i in range(5, end):
        print(i)


# Don't edit below this line


def test(end):
    print(f"Using input end: {end}")
    print(f"Printing numbers from 5 to {end - 1}:")
    print_numbers_from_five_to(end)
    print("=====================================")


def main():
    test(16)
    test(6)
    test(11)


main()
```

</section><!-- END .assignment-answer-sec -->



### â–¶ï¸ L4: Loop Review



### â–¶ï¸ L5: Loop Review



### â–¶ï¸ L6: Whitespace in Python


<section class="callout"><span class="label-verbatim">COPIED VERBATIM:  ğŸ‘‡ğŸ½</span>


The body of a for-loop _must_ be indented, otherwise you'll get a syntax error. Not only that, but every line in the body of the loop must be indented in the same way - we use the "4 spaces" convention. Pressing the `<tab>` key should automatically insert 4 spaces.

_Whitespace matters in Python._

</section>

<BR>

> ğŸ’¡**TIP**: *Python uses the `4 spaces` convention for indentation.*


### â–¶ï¸ L7: Range Continued

<section class="callout"><span class="label-verbatim">COPIED VERBATIM:  ğŸ‘‡ğŸ½</span>


The `range()` function we've been using in our `for` loops actually has an optional 3rd parameter: the "step".

```py
for i in range(0, 10, 2):
    print(i)
# prints:
# 0
# 2
# 4
# 6
# 8
```

The "step" parameter determines how much to add to `i` in each iteration of the loop. You can even go backwards:

```py
for i in range(3, 0, -1):
    print(i)
# prints:
# 3
# 2
# 1
```

</section>

<section class="callout"><span class="label-verbatim">Assignment:  ğŸ‘‡ğŸ½</span>


## Assignment

Fix the `for` loop in the `count_down` function. It takes `start` and `end` inputs, but `start` is always greater than `end`. It's supposed to print numbers counting down, beginning at `start` (_inclusive_) and stopping just before `end` (_exclusive_), but there's a mistake in the `range` function call.

## Tip

In the programming world, it's common for the first number in a range to be _inclusive_ and the second number is _exclusive_. e.g. `range(0, 10)` will include:

```
0 1 2 3 4 5 6 7 8 9
```


</section>

<br>

<section class="assignment-answer-sec">

**âœï¸ ASSIGNMENT STARTING CODE:**

<span class="code-filename">main.py</span>

```py
def count_down(start, end):
    for i in range(start, end):
        print(i)


# Don't edit below this line


def test(start, end):
    print(f"Using inputs start: {start} and end: {end}")
    print(f"Printing numbers from {start} to {end + 1}:")
    count_down(start, end)
    print("=====================================")


def main():
    test(10, 0)
    test(20, 10)
    test(15, 11)


main()

```

**âœï¸ MY ANSWER:**

```py
def count_down(start, end):
    for i in range(start, end, -1):
        print(i)


# Don't edit below this line


def test(start, end):
    print(f"Using inputs start: {start} and end: {end}")
    print(f"Printing numbers from {start} to {end + 1}:")
    count_down(start, end)
    print("=====================================")


def main():
    test(10, 0)
    test(20, 10)
    test(15, 11)


main()
```

</section><!-- END .assignment-answer-sec -->

### â–¶ï¸ L8: Sum Game

<section class="callout"><span class="label-verbatim">COPIED VERBATIM:  ğŸ‘‡ğŸ½</span>

Remember you can use in-place operators to increase or decrease a variable by any amount.

```py
number_of_enemies = 10
number_of_enemies += 2
# number_of_enemies is 12
```

```py
number_of_enemies = 10
number_of_enemies -= 2
# number_of_enemies is 8
```

</section>

<section class="callout"><span class="label-verbatim">Assignment:  ğŸ‘‡ğŸ½</span>

## Assignment

Fix the bug in the `sum_of_numbers` function. Instead of adding 1 to `total` at each iteration of the loop, it should add `i`. For example, instead of:

`1 + 1 + 1 + 1 + 1...`

we want:

`0 + 1 + 2 + 3 + 4...`

The desired output is a single number after the loop has finished executing.

</section>

<br>

<section class="assignment-answer-sec">

**âœï¸ ASSIGNMENT STARTING CODE:**

<span class="code-filename">main.py</span>

```py
def sum_of_numbers(start, end):
    total = 0
    for i in range(start, end):
        total += 1
    return total

```

**âœï¸ MY ANSWER:**

```py
def sum_of_numbers(start, end):
    total = 0
    for i in range(start, end):
        total += i
    return total
```

</section><!-- END .assignment-answer-sec -->


### â–¶ï¸ L9: Sum Game 2

<section class="callout"><span class="label-verbatim">Assignment:  ğŸ‘‡ğŸ½</span>

## Assignment

Complete the `sum_of_odd_numbers` function. It should calculate the sum of all the odd numbers starting at 1 up to (but not including) the given `end` number and return the result.

## Tips

*   What number should you start with if you only want odd numbers?
*   How much should you increment by in each iteration of the loop to get the next odd number?

</section>

<br>

<section class="assignment-answer-sec">

**âœï¸ ASSIGNMENT STARTING CODE:**

<span class="code-filename">main.py</span>

```py
def sum_of_odd_numbers(end):
    total = 0
    for i in range(0, end):
        total += i
    return total
```

**âœï¸ MY ANSWER:**

```py
def sum_of_odd_numbers(end):
    total = 0
    for i in range(1, end, 2):

        # debugging ...
        print(f"i: {i}\ttotal: {total}")
        
        total += i
    return total
```

</section><!-- END .assignment-answer-sec -->



<span class="boot-dev-op">Live: Search for Challenges:</span>

<section class="boot-dev-op-sec">

Good afternoon fellow learners! I wanted to let you know that you can now search for existing challenges in the training grounds to jump straight in to top-rated premade challenges. If waiting for boots to generate a new challenge takes too long, or you just want to be sure that other students already vetted the challenge and its a good one - the new search bar is for you! Check it out in the [**training grounds**](https://www.boot.dev/training)

> NOTE: *This was from my achievement notifications, not this chapter*

</section>

<span class="boot-dev-op">Training Grounds:</span>

<section class="boot-dev-op-sec">

## Frequently Asked Questions

##### What are the Training Grounds?

The Training Grounds is a place to **review and practice** what you've learned in the courses. It's an "infinite" series of dynamically generated challenges **personalized to you**.

- - -

##### How are the challenges generated?

Using AI! That said, we've hand-written thousands of challenges, and used those to seed these newly generated ones - it's not just one-shot slop. The generation loop is an agentic system that takes the following into account:

*   [**Spaced repetition**](https://en.wikipedia.org/wiki/Spaced_repetition): We use a time-variable algorithm to surface topics you may need a refresher on.
*   **Personalization**: We try to only give you challenges that require knowledge you've already learned.
*   **Mastery**: We weight toward topics that you struggled with in the past.
*   **Correctness**: Our system runs the challenges to ensure generated solutions work before you start.
*   **Variety**: There are 3 types of challenges: write the code, fix the bug, and interview question.

- - -

##### How do custom instructions work?

If you _don't_ enter a custom prompt, you'll get a challenge based solely on your learning history. If you _do_ enter a custom prompt, we'll still use your history, but the system will override any of its choices with your instructions if they contradict.
- - -

##### How do the game-mechanics work?

Game mechanics like streaks, quests, sharpshooter etc. all work the same way in the Training Grounds as they do in the courses, but the base XP gain of challenges is 25% lower than in regular courses. Additionally, XP gain is reduced by 5% per challenge to a maximum of -50% per day.

- - -

##### What if the challenges are bad?

Challenges are AI generated, so occasionally you'll get some weird stuff, even with all the safeguards, prompts, tests, and hand-crafted examples we've put in place. Be sure to use the star ratings and skip button to give us feedback so that we can keep improving the system.

</section>


- **game lobby**: A virtual staging area in multiplayer games where players gather before gameplay to chat, form teams, set game options, and prepare for the match. It functions as a coordinated communication and organization space distinct from free-for-all chatrooms, fostering social interaction, strategy planning, and team readiness.

- **tuple**: an ordered collection of items in python that can't be changed after creation, often used to store fixed groups of values like coordinates or settings. Items can be any type and are enclosed in parentheses, separated by commas (*while common across languages their **size, element types, mutability, and syntax differ**.*)



<section class="challenge callout"><span class="label-challenge">CHALLENGE:  Build Player Handle ğŸ‘‡ğŸ½</span>

Complete the `build_player_handle` function.

You work on a game lobby system. Given a player's first name, last name, and a tag number, build two strings:

1.  A display name in the format: `"Last, First"`
2.  A short handle made from the first letter of the first name, the first letter of the last name, a dash, and the tag number: `"FL-7"`

Requirements:

*   Use multiple variable assignment to swap the first and last names before formatting the display name. For example: `a, b = b, a` assigns `b` to `a` and `a` to `b` in one line.
*   Use an [f-string](https://docs.python.org/3/tutorial/inputoutput.html#tut-f-strings) to build both strings. F-strings let you write strings like `f"Hello {name}"` where `{name}` is replaced by the variable's value.
*   Return a tuple: `(display_name, handle)`.

Important details about the handle:

*   The handle must use the first letter of the (original) first name followed by the first letter of the (original) last name, then a dash and the tag number. For example, for `first_name='Luke'`, `last_name='Skywalker'`, and `tag_number=7` the handle should be `"LS-7"`.

Examples:

```py
print(build_player_handle("Leia", "Organa", 24))
# ("Organa, Leia", "LO-24")

print(build_player_handle("Luke", "Skywalker", 7))
# ("Skywalker, Luke", "LS-7")
```

</section>

<br>

<section class="assignment-answer-sec">

**âœï¸ ASSIGNMENT STARTING CODE:**

<span class="code-filename">main.py</span>

```py
def build_player_handle(first_name, last_name, tag_number):
    pass
```

**âœï¸ MY ANSWER:**

```py
def build_player_handle(first_name, last_name, tag_number):
    fname_init = first_name[0]

    display_name = f"{last_name}, {first_name}"
    
    handle = f"{first_name[0]}{last_name[0]}-{tag_number}"
    
    return display_name, handle
```

</section><!-- END .assignment-answer-sec -->

<br>

> ğŸ’¡ **TIP**: *In Python you can get **use array indexing** to get the n-th character of a string (e.g., fname_init = `first_name[0]`*

<section class="challenge callout"><span class="label-challenge">CHALLENGE:  Fix Receipt Formatter ğŸ‘‡ğŸ½</span>

The `format_total` function should build a nicely formatted receipt line using function parameters and sensible defaults.

It must always return the formatted string. It should only print the string when asked to via a flag.

Your job: fix the buggy function so it matches the expected behavior below.

What it should do:

*   Calculate the amount as `subtotal + tax`.
*   If `show_currency` is `True`, include the `currency_symbol` right before the amount.
*   If `show_currency` is `False`, do not include any currency symbol.
*   Always return the final string.
*   Only print the final string when `print_result` is `True`.

Format:

*   `"<label>: <currency><amount>"`
*   Examples:
    *   `label="Total"`, `show_currency=True`, `currency_symbol="$"`, amount `15` â†’ `"Total: $15"`
    *   `label="Total"`, `show_currency=False`, amount `20` â†’ `"Total: 20"`

Notes:

*   This challenge focuses on functions, default parameters, and the difference between printing and returning.
*   Do not add loops or complex data structures.
*   Amounts in tests are whole numbers to avoid decimal formatting issues.

Examples:

```py
print(format_total(10, tax=5))
# Expected return value: "Total: $15"
# Expected printed output: nothing (empty)

print(format_total(7, tax=3, print_result=True))
# Expected return value: "Total: $10"
# Expected printed output: "Total: $10\n"

print(format_total(20, tax=0, show_currency=False))
# Expected return value: "Total: 20"
# Expected printed output: nothing (empty)
```

Expected behavior summary:

1.  Return the formatted string every time.
2.  Only print when `print_result` is `True`.
3.  Respect `show_currency` and `currency_symbol` when building the string.

</section>

<br>

<section class="assignment-answer-sec">

**âœï¸ ASSIGNMENT STARTING CODE:**

<span class="code-filename">main.py</span>

```py
def format_total(subtotal, tax=0, label="Total", show_currency=True, print_result=False, currency_symbol="$"):
    amount = subtotal + tax
    result = label + ": " + str(amount)
    print(result)
    return result
```

**âœï¸ MY ANSWER:**

```py
def format_total(subtotal, tax=0, label="Total", show_currency=True, print_result=False, currency_symbol="$"):
    amount = subtotal + tax

    if show_currency:
        result = f"{label}: {currency_symbol}{str(amount)}"
    else:
        result = label + ": " + str(amount)

    if print_result:
        print(result)
        
    return result
```

</section><!-- END .assignment-answer-sec -->



<section class="challenge callout"><span class="label-challenge">CHALLENGE:  Terminate the Loop (Interview with Boots) ğŸ‘‡ğŸ½</span>

Consider this pseudocode that scans a counter until a condition is met:

```
counter = START_VALUE   # some non-negative integer
flag = false

while counter >= 0 and not flag:
    if counter % 3 == 0:
        flag = true
    if counter % 2 == 0:
        continue
    counter = counter - 1
```

Hints and context:

*   The keyword "continue" skips the rest of the current loop iteration and jumps to the next iteration.
*   The loop should eventually stop either when `flag` becomes true or when `counter` drops below 0.
*   Think about whether the loop's progress (changing `counter`) can be skipped by any path through the conditionals.

</section>

<br>

<section class="assignment-answer-sec">

**âœï¸ ASSIGNMENT STARTING CODE:**

<span class="code-filename">main.py</span>

**âœï¸ MY ANSWER:** 

```py
counter = 11
flag = False

while counter >= 0 and not flag:

    print(counter)

    # If counter is multiple of 3
    if counter % 3 == 0:
        counter -= 1
        flag = True # early exit

    # If counter is multiple of 2
    elif counter % 2 == 0:
        counter -= 1
        continue # skip to next iteration

    else:
        counter -= 1
```

</section><!-- END .assignment-answer-sec -->







<!-- <section class="boots-feedback-sec"> -->
<section class="boots-feeback callout"><span class="label-boots-feeback">BOOTS' FEEDBACK ğŸ‘‡ğŸ½</span>


**âœï¸ BOOTS' FEEDBACK:**

## CORRECT! ğŸ†

Well done, apprentice. You identified the progress step (`counter -= 1`) and restructured the flow so it canâ€™t be skipped. In your revision:

*   You made the checks exclusive with `elif`, so only one path runs per iteration.
*   You placed the decrement before the `continue` and included it in every branch (including an `else`), guaranteeing progress each time.
*   You kept the original intent: set the flag when divisible by 3 and â€œskip the restâ€ on evens, while ensuring the loop always advances.

Your sketch shows it clearly:

```py
# python
while counter >= 0 and not flag:
    if counter % 3 == 0:
        counter -= 1
        flag = True
    elif counter % 2 == 0:
        counter -= 1
        continue
    else:
        counter -= 1
```

That structural change is exactly what was needed to ensure termination without changing what the loop is trying to detect.

</section>













### â–¶ï¸ L10: While

<section class="callout"><span class="label-verbatim">COPIED VERBATIM:  ğŸ‘‡ğŸ½</span>

Python has another type of loop, the `while` loop. It's a loop that continues `while` a condition remains `True`. The syntax is simple:

```py
while 1:
    print("1 evaluates to True")

# prints:
# 1 evaluates to True
# 1 evaluates to True
# (...continuing)
```

The example above is hardcoded to continue forever, creating an infinite loop. Typically, a `while` loop condition is a comparison or variable, and it determines when the loop ends:

```py
num = 0
while num < 3:
    num += 1
    print(num)

# prints:
# 1
# 2
# 3
# (the loop stops when num >= 3)
```

</section>

<section class="callout"><span class="label-verbatim">Assignment:  ğŸ‘‡ğŸ½</span>

## Assignment

In Fantasy Quest, player characters regenerate health when standing still while away from enemies. This means they will gain health but can't run from enemies that are coming towards them while regenerating.

Complete the `regenerate` function using a while loop. It takes `current_health`, `max_health` and `enemy_distance` integers and returns an integer.

1.  [ ] Use a `while` loop to determine if they can regenerate. Assume they're stationary and enemies are pursuing them. The character can regenerate while **both** of these conditions are true:
    *   [ ] The character's `current_health` is less than their `max_health`.
    *   [ ] An enemy is more than a distance of `3` from the character.
2.  [ ] For each iteration of the loop:
    *   [ ] The character gains `1` health.
    *   [ ] The `enemy_distance` shortens by `2`.
3.  [ ] Return the new `current_health` after regeneration stops.

## Tip

Ensure that the `return` statement is placed outside the `while` loop to correctly return the final value after the looping ends.


</section>

<br>

<section class="assignment-answer-sec">

**âœï¸ ASSIGNMENT STARTING CODE:**

<span class="code-filename">main.py</span>

```py
def regenerate(current_health, max_health, enemy_distance):
    pass
```

**âœï¸ MY ANSWER:**

```py
def regenerate(current_health, max_health, enemy_distance):
    
    while current_health < max_health and enemy_distance > 3:
        current_health += 1
        enemy_distance -= 2
    return current_health
```

</section><!-- END .assignment-answer-sec -->







### â–¶ï¸ L11: Continue Statement

<section class="callout"><span class="label-verbatim">COPIED VERBATIM:  ğŸ‘‡ğŸ½</span>

Sometimes, while looping through a sequence, you may find items that you want to _skip_. Python (like many programming languages) provides a way to do this: the `continue` statement.

`continue` means "go directly to the next iteration of this loop." Whatever else was supposed to happen in the current iteration is skipped.

Let's say we want to print all the numbers from 1 to 50, but skip every 7th number. We can use `continue` to do this, by keeping track of a counter:

```python
# Remember, `range` is inclusive of the start, but exclusive of the end
counter = 0
for number in range(1, 51):
    counter = counter + 1

    if counter == 7:
        counter = 0 # Reset the counter
        continue # Skip this number

    print(number)
```

What we'll see printed are all the numbers from 1 to 50, except for 7, 14, 21, 28, 35, 42, and 49.

## Avoiding Work

A `continue` statement _immediately_ halts the current iteration and jumps to the next one, which saves the program from doing unnecessary work.

For example, if we're calculating square roots, we might want to skip negative numbers to avoid some tricky math. `continue` lets us move on to the next number without wasting any time:

```python
numbers = [16, -4, 25, -9, 36, 0, 49]

for number in numbers:
    if number < 0:
        continue  # Skip negatives to avoid complex numbers

    print(f"The square root of {number} is {number ** 0.5}.")
```

Using `continue` to avoid pointless work can make your code run faster.

</section>

<section class="callout"><span class="label-verbatim">Assignment:  ğŸ‘‡ğŸ½</span>

## Assignment

In Fantasy Quest, we want to grant the player an enchantment for _every third quest_ that they complete. And the higher the number of quests completed, the stronger the enchantment.

**Fix the `award_enchantments` function.** It calculates the strength of the enchantment â€“ 5 times the number of quests completed â€“ and prints a message for the player. But we need to make sure this happens only once every third quest _within the loop_!

1.  [ ] At the beginning of the function, before the loop, initialize a `counter` variable to `0`.
2.  [ ] Within the `for` loop:
    1.  [ ] Add `1` to `counter` in each iteration, to keep track of how many quests we've seen.
    2.  [ ] If `counter` is less than `3`, `continue` to the next iteration.
    3.  [ ] Otherwise, we must have completed 3 quests! Reset `counter` to `0` before the enchantment is awarded.

</section>

<br>

<section class="assignment-answer-sec">

**âœï¸ ASSIGNMENT STARTING CODE:**

<span class="code-filename">main.py</span>

```py
def award_enchantments(start, end, step):
    for quest_number in range(start, end, step):
        enchantment_strength = quest_number * 5
        print(
            f"Enchantment of strength {enchantment_strength} awarded for completing {quest_number} quests!"
        )


# Don't touch below this line


def test(start, end, step):
    print(f"Testing with quests {start} through {end - 1}:")
    award_enchantments(start, end, step)
    print("========================================")


def main():
    test(1, 11, 1)
    test(20, 24, 1)
    test(10, 12, 1)
    test(11, 19, 1)


main()
```

**âœï¸ MY ANSWER:**

```py
// answer code here
```

</section><!-- END .assignment-answer-sec -->







### â–¶ï¸ L12: Break Statement

<section class="callout"><span class="label-verbatim">COPIED VERBATIM:  ğŸ‘‡ğŸ½</span>

// VERBATIM_CONTENT

</section>

<section class="callout"><span class="label-verbatim">Assignment:  ğŸ‘‡ğŸ½</span>

// ASSIGNMENT CONTENT

</section>

<br>

<section class="assignment-answer-sec">

**âœï¸ ASSIGNMENT STARTING CODE:**

<span class="code-filename">main.py</span>

```py
// answer starting code here
```

**âœï¸ MY ANSWER:**

```py
// answer code here
```

</section><!-- END .assignment-answer-sec -->







### â–¶ï¸ L13: Match Countdown

<section class="callout"><span class="label-verbatim">COPIED VERBATIM:  ğŸ‘‡ğŸ½</span>

// VERBATIM_CONTENT

</section>

<section class="callout"><span class="label-verbatim">Assignment:  ğŸ‘‡ğŸ½</span>

// ASSIGNMENT CONTENT

</section>

<br>

<section class="assignment-answer-sec">

**âœï¸ ASSIGNMENT STARTING CODE:**

<span class="code-filename">main.py</span>

```py
// answer starting code here
```

**âœï¸ MY ANSWER:**

```py
// answer code here
```

</section><!-- END .assignment-answer-sec -->







### â–¶ï¸ L14: Experience Points

<section class="callout"><span class="label-verbatim">COPIED VERBATIM:  ğŸ‘‡ğŸ½</span>

// VERBATIM_CONTENT

</section>

<section class="callout"><span class="label-verbatim">Assignment:  ğŸ‘‡ğŸ½</span>

// ASSIGNMENT CONTENT

</section>

<br>

<section class="assignment-answer-sec">

**âœï¸ ASSIGNMENT STARTING CODE:**

<span class="code-filename">main.py</span>

```py
// answer starting code here
```

**âœï¸ MY ANSWER:**

```py
// answer code here
```

</section><!-- END .assignment-answer-sec -->







### â–¶ï¸ L15: Meditate








<!-- END Lesson Notes -->

---


## References

- N/A

