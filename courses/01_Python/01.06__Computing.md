<!-- 🔗 Custom Stylesheet -->
<link rel="stylesheet" href="../../_css/main.css">

<!-- 🖼️ Site Logo -->
![Site Logo](/_pix/logos/logo-ehw-kb-h32.png)


<!-- 📝 Title -->
# 📒 COURSE NOTES: <span class="course-title">[Learn to Code in Python](https://www.boot.dev/lessons/78b4646f-85aa-42c7-ba46-faec2f0902a9)</span>


## 📂 Chapter 06: **Computing**

* **Chapter URL:** https://www.boot.dev/lessons/e70822c0-6850-42d1-ad0d-57ee5fbae6b4


<!-- 🧭 Navigation -->
### [🏚️ README](../../README.md) | [📁 Index](index.md) | [🔖 Bookmark](#bookmark)

<span class="success-banner">DONE! (10/28/25)</span>


<br>

**In this Chapter:**


<section class="ehw-doc-descr">  

These are my personal notes from **Boot.dev’s Chapter 06: Computing**. This chapter explores Python’s **numeric and logical foundation**, covering **integer** and **float** types, **floor division**, **exponents**, **reassignment operators** like `+=`, and **scientific notation**. It then transitions into **boolean logic** with `and`, `or`, and `not`, followed by **binary representation** and **bitwise operations** (`&`, `|`).


</section>  

### Applied Examples

| #️⃣   | Example                               | Details |
| --- | ------------------------------------- | ------- |
| 1   | guild permission systems              | -       |
| 2   | calculating damage per second         | -       |
| 3   | converting binary strings to integers | -       |

<!-- 🏷️ RELATED TAGS -->
<section id="sec-tags">  

## 🏷️ Tags:  

- Python  
- Computing  
- Arithmetic Operators  
- Logical Operators  
- Bitwise Operations  
- Binary  
- Permissions  
- Data Conversion  


</section>



---


<!-- 📖 TOC (Table of Content) -->
<details open>

<summary>Table of Contents</summary>

- [📒 COURSE NOTES: Learn to Code in Python](#-course-notes-learn-to-code-in-python)
  - [📂 Chapter 06: **Computing**](#-chapter-06-computing)
    - [🏚️ README | 📁 Index | 🔖 Bookmark](#️-readme---index---bookmark)
    - [Applied Examples](#applied-examples)
  - [🏷️ Tags:](#️-tags)
    - [▶️ L1: Python Numbers](#️-l1-python-numbers)
    - [▶️ L2: Numbers Review](#️-l2-numbers-review)
    - [▶️ L3: Floor Division](#️-l3-floor-division)
    - [▶️ L4: Exponents](#️-l4-exponents)
    - [▶️ L5: Changing in Place](#️-l5-changing-in-place)
    - [▶️ L6: Plus Equals](#️-l6-plus-equals)
    - [▶️ L7: Scientific Notation](#️-l7-scientific-notation)
    - [📝 **Summary**](#-summary)
    - [My Answer:](#my-answer)
    - [▶️ L8: Logical Operators](#️-l8-logical-operators)
    - [Python Syntax](#python-syntax)
    - [Nesting With Parentheses](#nesting-with-parentheses)
    - [▶️ L9: Not](#️-l9-not)
    - [▶️ L10: Binary Numbers](#️-l10-binary-numbers)
    - [Binary in Python](#binary-in-python)
    - [▶️ L11: Binary Numbers](#️-l11-binary-numbers)
    - [▶️ L12: Binary Numbers](#️-l12-binary-numbers)
    - [▶️ L13: Bitwise '\&' Operator](#️-l13-bitwise--operator)
    - [Binary Notation](#binary-notation)
    - [Putting It Together](#putting-it-together)
  - [Guild Permissions](#guild-permissions)
  - [Assignment](#assignment)
    - [▶️ L14: Bitwise '|' Operator](#️-l14-bitwise--operator)
  - [Guild Permissions](#guild-permissions-1)
  - [Assignment](#assignment-1)
    - [▶️ L15: Damage Meter](#️-l15-damage-meter)
  - [Assignment](#assignment-2)
    - [▶️ L16: Converting Binary](#️-l16-converting-binary)
- [Converting Binary](#converting-binary)
  - [Assignment](#assignment-3)
  - [References](#references)


</details>
<!-- Lesson Notes -->


### ▶️ L1: Python Numbers


- **integer**: whole numbers, positive or negative; numbers without a decimal point.

- **float**: a number type that allows decimal values.

<section class="info-banner"><span>💡 PRO TIP: </span>

Division on two integers produces a [**float**](https://docs.python.org/3/tutorial/floatingpoint.html)

</section>



### ▶️ L2: Numbers Review



### ▶️ L3: Floor Division


- **floored**: rounded **down** to the nearest integer; uses the `//` operator.

**Example:**

```py
7 // 3
# 2 (an integer, rounded down from 2.333)
-7 // 3
# -3 (an integer, rounded down from -2.333)
```

<section class="info-banner"><span>💡 PRO TIP: </span>

In floor division the remainder is dropped and the number is always rounded down (so with negative numbers -5.2 floors to -6)

</section>

### ▶️ L4: Exponents

<section class="info-banner"><span>💡 PRO TIP: </span>

Python has **built-in support for exponents** - something most languages require a math library for.

</section>

**Example**:

```py
# reads as "three squared" or
# "three raised to the second power"
3 ** 2
# 9
```

- Anything raised to the power of 1 is itself
- Anything raised to the zero is 1


- exponent operator = `**`




### ▶️ L5: Changing in Place

It's fairly common to want to change the value of a variable based on its current value.

```py
player_score = 4
player_score = player_score + 1
# player_score now equals 5
```

```py
player_score = 4
player_score = player_score - 1
# player_score now equals 3
```

### ▶️ L6: Plus Equals

Python simplifies variable reassignment during mathematical operations by using in-place operators like `+=`. While languages like JavaScript or Go commonly use the `++` syntax to increment a value by 1, Python does not support `++`. Instead, Python uses `+= 1` to achieve the same result, which is both clear and consistent with other compound assignment operations (like `-=`, `*=`, and `/=`).


* **Reassignment**: Updating the value of an existing variable with a new value, often as part of a mathematical operation.
* **In-place operator**: An operator that updates a variable’s value by performing an operation and assigning the result back to the same variable (e.g., `+=`, `-=`, `*=`).
* **`+=` operator**: An in-place addition operator in Python that increases a variable's value by a specified amount and reassigns it to the same variable.
* **`++` operator**: A shorthand increment operator used in languages like JavaScript and Go to increase a variable's value by 1; not supported in Python.

**Example:**

```py
star_rating = 4
star_rating += 1
# star_rating is now 5
```

**Demonstrating other similar `in-place` operators:**

```py
star_rating = 4
star_rating -= 1
# star_rating is now 3

star_rating = 4
star_rating *= 2
# star_rating is now 8

star_rating = 4
star_rating /= 2
# star_rating is now 2.0
```

> 💡 You cannot use `-=` in a return statement. Set the variable first, and then return it after!


### ▶️ L7: Scientific Notation


### 📝 **Summary**

This section introduces scientific notation in Python, which allows representation of very large or small numbers using `e` followed by an exponent. It also explains how Python permits the use of underscores in numbers to make them easier to read without affecting their actual value.

* **Scientific Notation**: A way to represent **very large or very small numbers** using the letter `e` or `E` followed by an exponent. For example, `1.024e18` means move the decimal 18 places to the right, resulting in `1,024,000,000,000,000,000.0`.

* **Exponent (in scientific notation)**: The number after `e` that indicates how many decimal places to move. A positive exponent moves the decimal to the right; a negative exponent moves it to the left.

* **Float**: A data type in Python representing real numbers, including those written in scientific notation. Even large whole numbers like `1.024e18` are treated as floats (`1.024e18` becomes `1.024 × 10¹⁸`, or `1,024,000,000,000,000,000.0`).

* **Underscore in Numbers**: A feature in Python that allows using underscores (`_`) in numeric literals to improve readability. For example, `16_000_000` is interpreted as `16000000`.



**Example:**

```py
print(16e3)
# Prints 16000.0

print(7.1e-2)
# Prints 0.071
```


> 💡 Python allows you to use underscores `_` in long numbers (positive or negative) for readability


**Example:**

```py
num = 16_000
print(num)
# Prints 16000

num = 16_000_000
print(num)
# Prints 16000000
```


<section class="callout"><span class="label-verbatim">Assignment 👇🏽</span>

Due to the constraints of our app's server, there is a maximum number of players we can have on a single Fantasy Quest server.

Complete the `max_players_on_server` function. It takes no inputs, but simply returns 3 static numbers:

  1. The max players on a "small" server: `1,024,000,000,000,000,000` (1.024e18)
  2. The max players on a "medium" server: `10,240,000,000,000,000,000`
  3. The max players on a "large" server: `102,400,000,000,000,000,000`

Use scientific notation to represent these numbers. For example: `3.104e15`.

</section>

<br>



### My Answer:

```py
def max_players_on_server():
    max_players_sm = 1.024e18
    max_players_med = 10.24e18
    max_players_lg = 102.4e18
    return max_players_sm, max_players_med, max_players_lg
```






> 💡 Numbers in scientific notation are floats. For example, `1.024e18` is actually equivalent to `1,024,000,000,000,000,000.0` (note the `.0` at the end). This is expected and perfectly fine for this assignment.

### ▶️ L8: Logical Operators


Logical operators deal with boolean values, True and False.

The logical and operator requires that both inputs are True to return True. The logical or operator only requires that at least one input is True to return True.

For example:

```py
True and True == True
True and False == False
False and False == False

True or True == True
True or False == True
False or False == False
```

### Python Syntax

```py
print(True and True)
# prints True

print(True or False)
# prints True
```

### Nesting With Parentheses

We can nest logical expressions using parentheses.

```py
print((True or False) and False)
```

First, we evaluate the expression in the parentheses, (True or False). It evaluates to True:

```py
print(True and False)
```

True and False evaluates to False:

```py
print(False)
```

So, `print((True or False) and False)` prints "False" to the console.

### ▶️ L9: Not

We skipped a very important logical operator - not. The not operator reverses the result. It returns False if the input was True and vice-versa.

```py
print(not True)
# Prints: False

print(not False)
# Prints: True
```

### ▶️ L10: Binary Numbers

Binary numbers are just "base 2" numbers. They work the same way as "normal" base 10 numbers, but with two symbols instead of ten.

- Base-2 (binary) symbols: 0 and 1
- Base-10 (decimal) symbols: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9


Each 1 in a binary number represents an ever-greater multiple of 2. In a 4-digit number, that means you have the eights place, the fours place, the twos place, and the ones place. Similar to how in decimal you would have the thousands place, the hundreds place, the tens place, and the ones place.


### Binary in Python
You can write an integer in Python using binary syntax using the 0b prefix:

```py
print(0b0001)
# Prints 1

print(0b0101)
# Prints 5
```

> 💡 ***Leading 0s** are often added for visual consistency but do not change the value of a binary number.*

### ▶️ L11: Binary Numbers



### ▶️ L12: Binary Numbers



### ▶️ L13: Bitwise '&' Operator

Bitwise operators are similar to logical operators, but instead of operating on boolean values, they apply the same logic to all the bits in a value by column. For example, say you had the numbers 5 and 7 represented in binary. You could perform a bitwise AND operation and the result would be 5.

- 0101 is 5
- 0111 is 7

```py
0101
&
0111
=
0101
```

A 1 in binary is the same as True, while 0 is False. So really a bitwise operation is just a bunch of logical operations that are completed in tandem by column.

```py
0 & 0 = 0

1 & 1 = 1

1 & 0 = 0
```

Ampersand & is the bitwise AND operator in Python. "AND" is the name of the bitwise operation, while ampersand & is the symbol for that operation. For example, 5 & 7 = 5, while 5 & 2 = 0.

- 0101 is 5
- 0010 is 2

```py
0101
&
0010
=
0000
```

### Binary Notation
When writing a number in binary, the prefix `0b` is used to indicate that what follows is a binary number. 0b10 is two in binary, but 10 without the 0b prefix is simply ten.

- `0b0101` is 5
- `0b0111` is 7

### Putting It Together

```py
0b0101 & 0b0111
# equals 5

binary_five = 0b0101
binary_seven = 0b0111
binary_five & binary_seven
# equals 5
```

> 💡 Learn more about [**binary masking**](../articles/01.06.01__binary-masking.md)

<BR>

---

<section class="callout"><span class="label-verbatim">COPIED VERBATIM:  👇🏽</span>

## Guild Permissions

Sometimes applications store user permissions as binary values. If I have `4` different permissions a user can have, then I can store that as a 4-digit binary number, and if a certain bit is present, I know the permission is enabled. This can be a lot more efficient than storing entire strings.

Let's pretend we have 4 permissions related to "guilds" in Fantasy Quest ("guild" is just a fancy videogame word for "team"):

*   `can_create_guild` - Leftmost bit (`0b1000`)
*   `can_review_guild` - Second to leftmost bit (`0b0100`)
*   `can_delete_guild` - Second to rightmost bit (`0b0010`)
*   `can_edit_guild` - Rightmost bit (`0b0001`)

If a user has _no_ permissions, their binary permissions would be `0b0000`.

If a user only has the `can_create_guild` permission, their binary permissions would be `0b1000`, but a user with `can_review_guild` _and_ `can_edit_guild` permissions would be `0b0101`.

To check for, say, the `can_review_guild` permission, we can perform a bitwise AND operation on the user's permissions and the enabled `can_review_guild` bit (`0b0100`). If the result is `0b0100` again, we know they have that specific permission!

```py
user_permissions = 0b0101
can_review_guild = 0b0100

# perform bitwise AND to get the user's review permission
user_review_guild_permission = user_permissions & can_review_guild

# check if the user's review permission is equal to `can_review_guild`
```

</section>


<section class="callout"><span class="label-verbatim">Assignment:  👇🏽</span>

## Assignment

Complete each of the `get_XXX_bits` functions. Simply use the bitwise `&` operation on the input of the user's permission bits and the appropriate guild permission bits variable, and return the resulting bits for them to be checked by the tests.

4 values have been provided, use the appropriate one for each function:

*   `can_create_guild`
*   `can_review_guild`
*   `can_delete_guild`
*   `can_edit_guild`

The `get_XXX_bits` functions return the bits and the test code compares the result to the original permission value to see if it matches!

</section>

<br>

**✍️ MY ANSWER:**

<span class="code-filename">main.py</span>

```py
can_create_guild = 0b1000
can_review_guild = 0b0100
can_delete_guild = 0b0010
can_edit_guild = 0b0001


def get_create_bits(user_permissions):
    user_create_perm = user_permissions & can_create_guild
    return user_create_perm


def get_review_bits(user_permissions):
    user_review_perm = user_permissions & can_review_guild
    return user_review_perm


def get_delete_bits(user_permissions):
    user_delete_perm = user_permissions & can_delete_guild
    return user_delete_perm


def get_edit_bits(user_permissions):
    user_edit_perm = user_permissions & can_edit_guild
    return user_edit_perm
```





### ▶️ L14: Bitwise '|' Operator


As you may have guessed, the bitwise "or" operator is similar to the bitwise "and" operator in that it works on binary rather than boolean values. However, the bitwise "or" operator "or"s the bits together. Here's an example:

*   `0101` is 5
*   `0111` is 7

```
0101
|
0111
=
0111
```

A `1` in binary is the same as `True`, while `0` is `False`. So a bitwise operation is just a bunch of logical operations that are completed in tandem. When two binary numbers are "or"ed together, the result has a `1` in any place where _either_ of the input numbers has a `1` in that place.

`|` is the bitwise "or" operator in Python. `5 | 7 = 7` and `5 | 2 = 7` as well!

*   `0101` is 5
*   `0010` is 2

```
0101
|
0010
=
0111
```

## Guild Permissions

A "guild" is a team of 2-4 players. Here are the guild-specific permissions:

*   `can_invite` - Leftmost bit (`0b1000`)
*   `can_kick` - Second to leftmost bit (`0b0100`)
*   `can_enter_dungeon` - Second to rightmost bit (`0b0010`)
*   `can_surrender` - Rightmost bit (`0b0001`)

When players are in a guild together, they gain _all_ the permissions of _all_ the other members of the guild!

For example, if:

*   Jack has the `can_invite` permission: `0b1000`
*   Jill has the `can_kick` permission: `0b0100`

Then, when they are partied together, they should both have the `can_invite` and `can_kick` permissions: `0b1100`.





---

<section class="callout"><span class="label-verbatim">Assignment:  👇🏽</span>

## Assignment

Complete the `calculate_guild_perms` function. It takes as input four binary numbers representing the separate permissions of each member of the guild: `glorfindel`, `galadriel`, `elendil` and `elrond`. It should return a single binary number that represents the combined permissions of _all_ the members of the guild.

Use a series of bitwise "or" operations to calculate the [superset](https://www.youtube.com/watch?v=1wsF9GpGd00) of all the member's permissions.

</section>

<br>


> 💡 **TIP**: *When players are in a guild together, they gain _all_ the permissions of _all_ the other members of the guild!*
> 
> 💡 **TIP**: *You can **chain** the "or" operator.*

<br>


**✍️ MY ANSWER:**

<span class="code-filename">main.py</span>

```py
def calculate_guild_perms(glorfindel, galadriel, elendil, elrond):
    guild_perms = glorfindel | galadriel | elendil | elrond
    return guild_perms
```




### ▶️ L15: Damage Meter


<section class="callout"><span class="label-verbatim">Assignment:  👇🏽</span>

You've been working with a group of interns to build a damage meter for Fantasy Quest... it's not going well.

## Assignment

**Fix the interns' syntax error**. The `calculate_dps` function should accept two arguments, but due to a syntax error, it's being called with 4 instead. Use the proper [delimiter](https://peps.python.org/pep-0515/) for thousands so that the numbers are still easy to parse visually.

The two numbers should be:

*   `damage`: 8 million, `time`: 45
*   `damage`: 10 million, `time`: 49



</section>

<br>


**✍️ MY ANSWER:**

<span class="code-filename">main.py</span>

```py
def main():
    # calculate_dps(8, 000, 000, 45)
    # calculate_dps(10, 000, 000, 49)
    damage_1 = 8e6
    calculate_dps(damage_1, 45)

    damage_2 = 10e6
    calculate_dps(damage_2, 49)

# Don't edit below this line


def calculate_dps(damage, time):
    dps = damage / time
    print(f"Damage per second: {dps}")
    print("=====================================")


main()
```



### ▶️ L16: Converting Binary

<section class="callout"><span class="label-verbatim">COPIED VERBATIM:  👇🏽</span>


# Converting Binary

Fantasy Quest needs to [migrate](https://en.wikipedia.org/wiki/Data_migration) old data from strings that _look like binary_ to the integers that the binary strings represent. For example:

*   `"100" -> 4`
*   `"101" -> 5`
*   `"10010" -> 18`

The built-in [int()](https://docs.python.org/3/library/functions.html#int) function can convert a binary string to an integer. It takes a second argument that specifies the base of the number (binary is base 2). For example:

```py
# this is a binary string
binary_string = "100"

# convert binary string to integer
num = int(binary_string, 2)
print(num)
# 4
```

</section>

<br>

> 💡 **TIP**: *The built-in **[int()](https://docs.python.org/3/library/functions.html#int)** function can convert a binary string to an integer.*
> 
> 💡 **TIP**: *The second parameter of the `int()` function is the base number (e.g, base-2, base-10, base-16, etc.)*

<br>

* **[data migration](../articles/01.06.02__data-migration.md)**: the overall process of moving data from one system, format, or location to another — often including extraction, transformation, and loading ([ETL](../articles/01.06.03__etl.md)) steps to ensure the data remains usable and accurate in its new environment.

* **data transformation**: a stage within data migration where data is changed or reshaped to fit the requirements of the destination system — such as cleaning, restructuring, or reformatting values.

* **data type conversion**: a *specific kind* of data transformation within data migration, where the **data’s representation changes from one type to another** (e.g., strings to integers, text dates to actual date objects). This ensures compatibility between systems and preserves meaning while adapting to new data formats.

  **Example:**
  Suppose a legacy system stores binary numbers as text, like `"1010"`.
  During migration, you might convert these string values into their integer equivalents for the new system:

  ```python
  binary_strings = ["1010", "1101", "100000"]
  integers = [int(b, 2) for b in binary_strings]
  print(integers)  # [10, 13, 32]
  ```

<br>

<section class="callout"><span class="label-verbatim">Assignment:  👇🏽</span>

## Assignment

Complete the `binary_string_to_int` function. It takes three binary strings as input and returns each of them in the same order as integers. Each integer is the numerical value of the string when interpreted as binary.

For example:

```py
data_a, data_b, data_c = binary_string_to_int("100", "101", "110")
print(data_a)
# 4
print(data_b)
# 5
print(data_c)
# 6
```

</section>

<br>


**✍️ MY ANSWER:**

<span class="code-filename">main.py</span>

```py
def binary_string_to_int(num_servers, num_players, num_admins):
    num_servers_int = int(num_servers, 2) 
    num_players_int = int(num_players, 2)
    num_admins_int = int(num_admins, 2)
    return num_servers_int, num_players_int, num_admins_int
```

**Results**

```
Inputs: 0, 0, 0
Expected: (0, 0, 0)
Actual:   (0, 0, 0)
Pass
---------------------------------
Inputs: 1111, 1111, 1111
Expected: (15, 15, 15)
Actual:   (15, 15, 15)
Pass
---------------------------------
Inputs: 101010, 110011, 101010
Expected: (42, 51, 42)
Actual:   (42, 51, 42)
Pass
============= PASS ==============
6 passed, 0 failed
```


<!-- END Lesson Notes -->

---


## References

- N/A

