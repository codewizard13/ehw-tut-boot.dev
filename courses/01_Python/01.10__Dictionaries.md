<!-- ğŸ”— Custom Stylesheet -->
<link rel="stylesheet" href="../../_css/main.css">

<!-- ğŸ–¼ï¸ Site Logo -->
![Site Logo](/_pix/logos/logo-ehw-kb-h32.png)


<!-- ğŸ“ Title -->
# ğŸ“’ COURSE NOTES: <span class="course-title">[Learn to Code in Python](https://www.boot.dev/lessons/78b4646f-85aa-42c7-ba46-faec2f0902a9)</span>

## ğŸ“‚ Chapter 10: **Dictionairies**

* **Chapter URL:** https://www.boot.dev/lessons/ff46b302-8371-4c3e-9dcd-3b306575ea02


<!-- ğŸ§­ Navigation -->
### [ğŸšï¸ README](../../README.md) | [ğŸ“ Index](index.md) | [ğŸ”– Bookmark](#bookmark)

<span class="warning-banner">IN-PROGRESS: 2025-11-06</span>


<br>

**In this Chapter:**  

<section class="ehw-doc-descr">  

### Learn to Code in Python, Ch. 10: *Dictionairies*

These are my personal notes on **<MAIN_TOPIC_LIST>** from Boot.dev. This chapter teaches how to <write 2-3 concise sentences summarizing what the chapter teaches and why it matters in real-world contexts, and clearly showing important bolded concepts and terms>.<end with the single-line real-world application / benefits sentence included at least 3 bolded real-world application phrases (e.g., medical software, debugging complex decision trees, gaming sofware, database management, livestreaming applications, industrial (PLC) logic controls, robotics, roomba robot vaccuums, etc.)>.   

### Learning Outcomes  

By the end of this chapter, I should be able to:  

- <Outcome 1 â€“ actionable and measurable>
- <Outcome 2 â€“ applying in different contexts>
- <Outcome 3 â€“ debugging or preventing common issues>
- <Outcome 4 â€“ explaining clearly>
- <Outcome 5 â€“ executing essential workflows>

</section>

### Applied Examples

| #ï¸âƒ£   | Example | Details |
| --- | ------- | ------- |
| 1   | --      | -       |
| 2   | --      | -       |
| 3   | --      | -       |

<!-- ğŸ·ï¸ RELATED TAGS -->
<section id="sec-tags">

## ğŸ·ï¸ Tags:

- Python
- dictionaries

</section>

---


<!-- ğŸ“– TOC (Table of Content) -->
<details open>

<summary>Table of Contents</summary>

- [ğŸ“’ COURSE NOTES: Learn to Code in Python](#-course-notes-learn-to-code-in-python)
  - [ğŸ“‚ Chapter 10: **Dictionairies**](#-chapter-10-dictionairies)
    - [ğŸšï¸ README | ğŸ“ Index | ğŸ”– Bookmark](#ï¸-readme---index---bookmark)
    - [Learn to Code in Python, Ch. 10: *Dictionairies*](#learn-to-code-in-python-ch-10-dictionairies)
    - [Learning Outcomes](#learning-outcomes)
    - [Applied Examples](#applied-examples)
  - [ğŸ·ï¸ Tags:](#ï¸-tags)
    - [â–¶ï¸ L1: Dictionaries](#ï¸-l1-dictionaries)
  - [Assignment](#assignment)
  - [Tips](#tips)
    - [â–¶ï¸ L2: Duplicate Keys](#ï¸-l2-duplicate-keys)
  - [Assignment](#assignment-1)
    - [â–¶ï¸ L3: Accessing Dictionary Values](#ï¸-l3-accessing-dictionary-values)
    - [â–¶ï¸ L4: Setting Dictionary Values](#ï¸-l4-setting-dictionary-values)
  - [Assignment](#assignment-2)
    - [â–¶ï¸ L5: Updating Dictionary Values](#ï¸-l5-updating-dictionary-values)
  - [Assignment](#assignment-3)
    - [â–¶ï¸ L6: Deleting Dictionary Values](#ï¸-l6-deleting-dictionary-values)
  - [Deleting Keys That Don't Exist](#deleting-keys-that-dont-exist)
    - [â–¶ï¸ L7: Counting Practice](#ï¸-l7-counting-practice)
  - [Checking for Existence](#checking-for-existence)
  - [Assignment](#assignment-4)
    - [â–¶ï¸ L8: Iterating Over a Dictionary in Python](#ï¸-l8-iterating-over-a-dictionary-in-python)
  - [Assignment](#assignment-5)
  - [Tip: Negative Infinity](#tip-negative-infinity)
    - [â–¶ï¸ L9: Ordered or Unordered?](#ï¸-l9-ordered-or-unordered)
- [Ordered or Unordered?](#ordered-or-unordered)
    - [â–¶ï¸ L10: Quest Status](#ï¸-l10-quest-status)
    - [â–¶ï¸ L11: Merge Dictionaries](#ï¸-l11-merge-dictionaries)
  - [References](#references)


</details>
<!-- Lesson Notes -->


### â–¶ï¸ L1: Dictionaries

<section class="callout"><span class="label-verbatim">COPIED VERBATIM:  ğŸ‘‡ğŸ½</span>

[Dictionaries](https://docs.python.org/3/tutorial/datastructures.html#dictionaries) in Python are used to store data values in `key` -> `value` pairs. Dictionaries are a great way to store groups of information.

```python
# use curly braces
# add key-value pairs
car = {
  "brand": "Toyota",
  "model": "Camry",
  "year": 2019,
}
```

Here the `car` variable is assigned to a dictionary `{}` containing the keys `brand`, `model` and `year`. The keys' corresponding values are `Toyota`, `Camry` and `2019`.

</section>

<section class="callout"><span class="label-verbatim">Assignment:  ğŸ‘‡ğŸ½</span>


## Assignment

Complete the `get_character_record` function. It takes a character's `name`, `server`, `level`, and `rank` as individual inputs, and returns a dictionary with the following string keys:

*   `"name"`
*   `"server"`
*   `"level"`
*   `"rank"`
*   `"id"`

1.  [ ] Create and return a dictionary with the keys above.
2.  [ ] Assign each of the four inputs to the matching key, ie: `"name": name`.

Next, we can't have two characters named `bloodwarrior123`'s on the same server!

3.  [ ] For the fifth key, `id`, create a unique value as follows:

Concatenate the `name` and the `server` inputs with a `#` in the middle. For example, given:

*   name = "bloodwarrior123"
*   server = "server1"

Then the `id` field would be set to `bloodwarrior123#server1`.

## Tips

*   You can return the dictionary directly without assigning it to a variable.
*   I recommend using an `f-string` to create the `id` field. This is a best practice.

</section>

<br>

<section class="assignment-answer-sec">

**âœï¸ ASSIGNMENT STARTING CODE:**

<span class="code-filename">main.py</span>

```py
def get_character_record(name, server, level, rank):
    pass
```

**âœï¸ MY ANSWER:**

```py
def get_character_record(name, server, level, rank):
    
    record = {
        "name": name,
        "server": server,
        "level": level,
        "rank": rank,
        "id": f"{name}#{server}"
    }

    return record
```

</section><!-- END .assignment-answer-sec -->

### â–¶ï¸ L2: Duplicate Keys

<section class="callout"><span class="label-verbatim">Assignment:  ğŸ‘‡ğŸ½</span>

Because dictionaries rely on unique keys, you can't have two of the same key in the same dictionary. If you try to use the same key twice, the first value will simply be overwritten.

## Assignment

Another developer on our team has introduced a bug by specifying duplicate keys in the dictionary! _Fix the bug._

The `get_character_record` function takes a character's `name`, `server`, `level`, and `rank`. It should return a dictionary with the following fields:

*   name
*   server
*   level
*   rank
*   id

Where the `id` is the `name` and the `server` concatenated together with a `#` in the middle for uniqueness. We can't have two `bloodwarrior123`'s on the same server!

</section>

<br>

<section class="assignment-answer-sec">

**âœï¸ ASSIGNMENT STARTING CODE:**

<span class="code-filename">main.py</span>

```py
def get_character_record(name, server, level, rank):
    return {
        "name": name,
        "server": server,
        "level": level,
        "level": 1,
        "rank": rank,
        "rank": 2,
        "id": f"{name}#{server}",
    }

```

**âœï¸ MY ANSWER:**

```py
def get_character_record(name, server, level, rank):
    return {
        "name": name,
        "server": server,
        "level": level,
        "rank": rank,
        "id": f"{name}#{server}",
    }
```

</section><!-- END .assignment-answer-sec -->

### â–¶ï¸ L3: Accessing Dictionary Values

<section class="callout"><span class="label-verbatim">COPIED VERBATIM:  ğŸ‘‡ğŸ½</span>

Dictionary elements must be accessible somehow in code, otherwise they wouldn't be very useful.

A value is retrieved from a dictionary by specifying its corresponding key in square brackets. The square brackets look similar to indexing into a list.

```python
car = {
    "make": "Toyota",
    "model": "Camry"
}
print(car["make"])
# Prints: Toyota
```

</section>


### â–¶ï¸ L4: Setting Dictionary Values

<section class="callout"><span class="label-verbatim">COPIED VERBATIM:  ğŸ‘‡ğŸ½</span>

You don't need to create a dictionary with values already inside. It is common to create a blank dictionary then populate it later using dynamic values. The syntax is the same as getting data out of a key, just use the assignment operator (`=`) to give that key a value.

```python
planets = {}
planets["Earth"] = True
planets["Pluto"] = False
print(planets["Pluto"])
# Prints False
```

</section>

<section class="callout"><span class="label-verbatim">Assignment:  ğŸ‘‡ğŸ½</span>


## Assignment

Use the example below to answer the question:

```python
names = ["jack bronson", "jill mcarty", "john denver"]

names_dict = {}
for name in names:
    # .split() returns a list of strings
    # where each string is a single word from the original
    name_list = name.split()

    # here we update the dictionary
    names_dict[name_list[0]] = name_list[1]

print(names_dict)
# Prints: {'jack': 'bronson', 'jill': 'mcarty', 'john': 'denver'}
```

</section>

<br>

> Note this was text answers only assignment

### â–¶ï¸ L5: Updating Dictionary Values

<section class="callout"><span class="label-verbatim">COPIED VERBATIM:  ğŸ‘‡ğŸ½</span>

If you try to set the value of a key that already exists, you'll end up just updating the value of that key.

```python
planets = {
    "Pluto": True,
}
planets["Pluto"] = False
print(planets["Pluto"])
# Prints False
```

</section>

<section class="callout"><span class="label-verbatim">Assignment:  ğŸ‘‡ğŸ½</span>


## Assignment

Use the example below to answer the question:

```python
full_names = ["jack bronson", "james mcarty", "jack denver"]

names_dict = {}
for full_name in full_names:
    # .split() returns a list of strings
    # where each string is a single word from the original
    names = full_name.split()
    first_name = names[0]
    last_name = names[1]
    names_dict[first_name] = last_name

print(names_dict)
# {
#   'jack': 'denver',
#   'james': 'mcarty'
# }
```

In this example, "denver" overwrote "bronson" as the value for the key "jack".

</section>

<br>

> Note this was text answers only assignment


### â–¶ï¸ L6: Deleting Dictionary Values

<section class="callout"><span class="label-verbatim">COPIED VERBATIM:  ğŸ‘‡ğŸ½</span>

You can delete existing keys using the `del` keyword.

```python
names_dict = {
    "jack": "bronson",
    "jill": "mcarty",
    "joe": "denver"
}

del names_dict["joe"]

print(names_dict)
# Prints: {'jack': 'bronson', 'jill': 'mcarty'}
```

## Deleting Keys That Don't Exist

Notice that if you try to delete a key that doesn't exist, you'll get an _error_.

```python
names_dict = {
    "jack": "bronson",
    "jill": "mcarty",
    "joe": "denver"
}

del names_dict["unknown"]
# ERROR HERE, key doesn't exist
```

</section>

<section class="callout"><span class="label-verbatim">Assignment:  ğŸ‘‡ğŸ½</span>

// ASSIGNMENT CONTENT

</section>

<br>

> Note this was text answers only assignment


### â–¶ï¸ L7: Counting Practice

<section class="callout"><span class="label-verbatim">COPIED VERBATIM:  ğŸ‘‡ğŸ½</span>

## Checking for Existence

If you're unsure whether a key exists in a dictionary, use the `in` keyword.

```python
cars = {
    "ford": "f150",
    "toyota": "camry"
}

print("ford" in cars)
# Prints: True

print("gmc" in cars)
# Prints: False
```

</section>

<section class="callout"><span class="label-verbatim">Assignment:  ğŸ‘‡ğŸ½</span>


## Assignment

We need to be able to report to our players how many enemies are in their immediate vicinity - but they want the count of each enemy by its _kind_. Fix the `count_enemies` function. It accepts as input:

*   `enemy_names`: a list of strings.

It should return a dictionary where:

*   The keys are all the enemy names from the list
*   The values are the counts of how many times each enemy appeared in the list.

1.  [ ] Run the code in its current state. It will raise a [KeyError](https://docs.python.org/3/library/exceptions.html#KeyError).
2.  [ ] Fix the code by checking _if_ a key is _in_ the dictionary before trying to update its value. If it isn't, set it.

</section>

<br>

<section class="assignment-answer-sec">

**âœï¸ ASSIGNMENT STARTING CODE:**

<span class="code-filename">main.py</span>

```py
def count_enemies(enemy_names):
    enemies_dict = {}
    for enemy_name in enemy_names:
        enemies_dict[enemy_name] += 1
    return enemies_dict
```

**âœï¸ MY ANSWER:**

```py
def count_enemies(enemy_names):
    enemies_dict = {}
    
    for enemy_name in enemy_names:

        if enemy_name in enemies_dict:
            enemies_dict[enemy_name] += 1
        else:
            enemies_dict[enemy_name] = 1
            
    return enemies_dict
```

**ğŸ“ˆ OUTPUT RESULTS**

```sh
---------------------------------
Inputs: ['jackal', 'kobold', 'soldier']
Expected: {'jackal': 1, 'kobold': 1, 'soldier': 1}
Actual:   {'jackal': 1, 'kobold': 1, 'soldier': 1}
Pass
---------------------------------
Inputs: ['jackal', 'kobold', 'jackal']
Expected: {'jackal': 2, 'kobold': 1}
Actual:   {'jackal': 2, 'kobold': 1}
Pass
============= PASS ==============
2 passed, 0 failed, 6 skipped
```

</section><!-- END .assignment-answer-sec -->

### â–¶ï¸ L8: Iterating Over a Dictionary in Python

<section class="callout"><span class="label-verbatim">COPIED VERBATIM:  ğŸ‘‡ğŸ½</span>

We can iterate over a dictionary's keys using the same no-index syntax we used to iterate over the values in a list. With access to the dictionary's keys, we also have access to their corresponding values.

```python
fruit_sizes = {
    "apple": "small",
    "banana": "large",
    "grape": "tiny"
}

for name in fruit_sizes:
    size = fruit_sizes[name]
    print(f"name: {name}, size: {size}")

# name: apple, size: small
# name: banana, size: large
# name: grape, size: tiny
```

We could have just as easily set the `name` variable to `key` or simply `k`.

</section>

<section class="callout"><span class="label-verbatim">Assignment:  ğŸ‘‡ğŸ½</span>


## Assignment

We need to display on our players' screens what the most common enemy in a given area of the game map is.

Complete the `get_most_common_enemy` function by iterating over all enemies in the dictionary and returning only the _name_ of the enemy with the highest count.

If there are no enemies, return the Python `None` value (not a string). If there are multiple enemies with the same highest count, return the first one found.

`enemies_dict` is a dictionary of `name` -> `count`. Example:

```py
{
    "jackal": 1,
    "kobold": 2,
    "soldier": 3,
    "gremlin": 5
}
```

## Tip: Negative Infinity

When you're trying to find a "max" value, it helps to keep track of the "max so far" in a variable and to start that variable at the lowest possible number, negative infinity.

```py
max_so_far = float("-inf")
```

You'll also want to keep track of the enemy name associated with the maximum count. I would set the default for that variable to `None`.


</section>

<br>

<section class="assignment-answer-sec">

**âœï¸ ASSIGNMENT STARTING CODE:**

<span class="code-filename">main.py</span>

```py
def get_most_common_enemy(enemies_dict):
    pass
```

**âœï¸ MY ANSWER:**

```py
def get_most_common_enemy(enemies_dict):
    
    # early exit if no enemies
    if len(enemies_dict) == 0:
        return None

    max_so_far = float("-inf")
    most_common_enemy = None

    for name in enemies_dict:

        count = enemies_dict[name]

        if count > max_so_far:
            most_common_enemy = name
            max_so_far = count

        elif count == max_so_far:
            return most_common_enemy 

    return most_common_enemy
```

</section><!-- END .assignment-answer-sec -->

### â–¶ï¸ L9: Ordered or Unordered?

<section class="callout"><span class="label-verbatim">COPIED VERBATIM:  ğŸ‘‡ğŸ½</span>

# Ordered or Unordered?

As of Python version `3.7`, dictionaries are _ordered_. In Python `3.6` and earlier, dictionaries were _unordered_.

Because dictionaries are ordered, the items have a defined order, and that order will _not_ change.

Unordered means that the items do _not_ have a defined order, so you couldn't refer to an item by using an index.

**The takeaway is that if you're on Python `3.7` or later, you'll be able to iterate over dictionaries in the same order every time.**

</section>



</section><!-- END .assignment-answer-sec -->

### â–¶ï¸ L10: Quest Status

<section class="callout"><span class="label-verbatim">COPIED VERBATIM:  ğŸ‘‡ğŸ½</span>

Fantasy Quest stores each character's progress in a nested dictionary structure. Here's what it looks like:

```py
{
    "character_name": "Kaladin",
    "quests": {
        "bridge_run": {
            "status": "In Progress",
        },
        "talk_to_syl": {
            "status": "Completed",
        },
    },
}
```

The _values_ can change of course, but the _structure_ will always be the same. For example, another character's progress might look like this:

```py
{
    "character_name": "Shallan",
    "quests": {
        "bridge_run": {
            "status": "Completed",
        },
        "talk_to_syl": {
            "status": "In Progress",
        },
    },
}
```

</section>

<section class="callout"><span class="label-verbatim">Assignment:  ğŸ‘‡ğŸ½</span>


**Complete the `get_quest_status` function.** It accepts a progress dictionary (structure defined above) and returns the character's status in the `"bridge_run"` quest.

Note, you can _chain dictionary keys_ to access a dictionary inside another dictionary:

```py
outer_dictionary["outer_key"]["inner_key"]
```


</section>

<br>

<section class="assignment-answer-sec">

**âœï¸ ASSIGNMENT STARTING CODE:**

<span class="code-filename">main.py</span>

```py
def get_quest_status(progress):
    pass
```

**âœï¸ MY ANSWER:**

```py
def get_quest_status(progress):

    return progress['quests']['bridge_run']['status']
```

</section><!-- END .assignment-answer-sec -->

### â–¶ï¸ L11: Merge Dictionaries

<section class="callout"><span class="label-verbatim">COPIED VERBATIM:  ğŸ‘‡ğŸ½</span>

// VERBATIM_CONTENT

</section>

<section class="callout"><span class="label-verbatim">Assignment:  ğŸ‘‡ğŸ½</span>

// ASSIGNMENT CONTENT

</section>

<br>

<section class="assignment-answer-sec">

**âœï¸ ASSIGNMENT STARTING CODE:**

<span class="code-filename">main.py</span>

```py
// answer starting code here
```

**âœï¸ MY ANSWER:**

```py
// answer code here
```

</section><!-- END .assignment-answer-sec -->






<!-- END Lesson Notes -->

---


## References

- N/A

