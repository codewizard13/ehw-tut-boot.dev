<!-- 🔗 Custom Stylesheet -->
<link rel="stylesheet" href="../../_css/main.css">

<!-- 🖼️ Site Logo -->
![Site Logo](/_pix/logos/logo-ehw-kb-h32.png)


<!-- 📝 Title -->
# 📒 COURSE NOTES: <span class="course-title">[Learn to Code in Python](https://www.boot.dev/lessons/f8e09afb-9769-4ad0-b3d4-95643603c433)</span>


## 📂 Chapter 05: **Testing and Debugging**

* **Chapter URL:** [url_for_this_chapter]


<!-- 🧭 Navigation -->
### [🏚️ README](../../README.md) | [📁 Index](index.md) | [🔖 Bookmark](#bookmark)

<span class="success-banner">DONE! (10/13/25)</span>


## Bookmark


<br>

**In this Chapter:**


<section class="ehw-doc-descr">

In this chapter, you’ll learn how to **test and debug Python code effectively**, using both **unit tests** and **console output** lessons. You’ll explore why automated tests are important and how Boot.dev simulates real-world conditions through `Run` and `Submit` tests. You’ll also practice **debugging skills**—using `print()` statements, reading **stack traces**, and fixing common issues like **indentation errors** and **NoneType** bugs. Finally, you’ll develop strategies for **learning effectively**, building persistence, and improving your problem-solving process through incremental debugging and code testing.

### Learning Outcomes

By the end of this chapter, you should be able to:

- Understand the difference between **unit-test lessons** and **console output lessons**.
- Use the **Run** button for debugging and the **Submit** button for comprehensive testing.
- Identify and fix common coding errors using **stack traces** and diagnostic prints.
- Apply a **structured approach** to solving harder coding problems.
- Cultivate effective learning and debugging habits that mirror professional development practices.


</section>


<!-- 🏷️ RELATED TAGS -->
<section id="sec-tags">

## 🏷️ Tags:

- Python
- Debugging
- Unit Testing
- Stack Trace
- Error Handling
- Learning Strategies
- Boot.dev
- Print Statements
- Troubleshooting

</section>

---


<!-- 📖 TOC (Table of Content) -->
<details open>

<summary>Table of Contents</summary>

- [📒 COURSE NOTES: Learn to Code in Python](#-course-notes-learn-to-code-in-python)
  - [📂 Chapter 05: **Testing and Debugging**](#-chapter-05-testing-and-debugging)
    - [🏚️ README | 📁 Index | 🔖 Bookmark](#️-readme---index---bookmark)
  - [Bookmark](#bookmark)
    - [Learning Outcomes](#learning-outcomes)
  - [🏷️ Tags:](#️-tags)
    - [▶️ L1: Unit Tests](#️-l1-unit-tests)
    - [▶️ L2: Two Lesson Types](#️-l2-two-lesson-types)
      - [Console Output Lessons](#console-output-lessons)
      - [Unit-Test Lessons](#unit-test-lessons)
    - [▶️ L3: Debugging](#️-l3-debugging)
      - [Run vs. Submit](#run-vs-submit)
      - [The Submit Button Will Run Additional Tests](#the-submit-button-will-run-additional-tests)
    - [▶️ L4: Learning Effectively](#️-l4-learning-effectively)
      - [⚡ This course is **about to get a bit harder**.](#-this-course-is-about-to-get-a-bit-harder)
      - [Process for Solving Hard Coding Problems](#process-for-solving-hard-coding-problems)
      - [Additional Tidbits](#additional-tidbits)
    - [▶️ L5: Learning Effectively](#️-l5-learning-effectively)
    - [▶️ L6: Learning Effectively](#️-l6-learning-effectively)
    - [▶️ L7: Debugging Practice](#️-l7-debugging-practice)
      - [Assignment](#assignment)
    - [Error Section](#error-section)
    - [▶️ L8: Stack Trace](#️-l8-stack-trace)
  - [References](#references)


</details>
<!-- Lesson Notes -->


### ▶️ L1: Unit Tests


- **unit test**: automated program that tests a small 'unit' of code


<span class="boot-dev-op">Unit Tests - A New Type of Lesson:</span>

<section class="boot-dev-op-sec">

Going forward, you'll encounter a new type of lesson: [unit tests](https://en.wikipedia.org/wiki/Unit_testing). A unit test is just an automated program that tests a small "unit" of code. Usually just a function or two. The editor will have tabs: the '**main.py**' file **containing your code**, and the '**main_test.py**' file **containing the unit tests**. 

- ⌨️ The shortcut to switch tabs is typically `Alt+Shift+[` on QWERTY keyboards. This shortcut may vary depending on your keyboard layout.

These new **unit-test-style lessons** will test your code's _functionality_ rather than its output. Our tests will call functions in your code with different arguments, and expect certain return values. If your code returns the correct values, you pass. If it doesn't, you fail.

> 💡  If your code returns the correct values, you pass. If it doesn't, you fail.

There are two reasons for this change:

1. It's more realistic. In the **real world**, you'll be writing unit tests and running them against your code to make sure it works as expected.

1. You can run and debug your code with `print` statements, and leave those print statements in when you submit. Unlike the output-based lessons, **you won't have to remove your `print` statements to pass**.

> 💡  You can leave your print debug statements in and still pass.

Also, `▶ Run` and `▶ Submit` work a little differently than before. When you run your code, it only runs some of the tests, but when you submit your code, it runs _all_ of the tests. This is to **simulate a production environment** with unexpected **edge cases** and to teach you to think them through. Luckily for you, all of the tests are visible in the `main_test.py` file tab, so be sure to check it before submitting.

> 💡  When you run your code, it only runs some of the tests, but when you submit your code, it runs all of the tests!



</section>




<section class="info-banner"><span>💡 PRO TIP: </span>

The `pass` keyword is a way to tell Python to do nothing.

</section>


<section class="info-banner"><span>💡 PRO TIP: </span>

When you receive `NoneType` errors always check to ensure you are returning a value when a value is expected

</section>




**Example:**

<section class="callout"><span class="label-verbatim">Assigment 👇🏽</span>

Complete the `total_xp` function. It accepts two integers as input:

- `level`
- `xp_to_add`

There are 100 xp per level. `total_xp` should convert the current `level` to xp, then add this current xp to the `xp_to_add` argument and return the player's total xp. For example:

- If a player is level 1 and gains 100 xp, they have 200 total xp.
- If a player is level 2 and gains 250 xp, they have 450 total xp.
- If a player is level 170 and gains 590 xp, they have 17590 total xp.

</section>

<br>

**✍️ MY ANSWER:**

<span class="code-filename">main.py</span>

```py
def total_xp(level, xp_to_add):
    current_xp = level * 100
    xp_ttl = xp_to_add + current_xp
    return xp_ttl
```

**THEIR UNIT TEST CODE:**

<span class="code-filename">main_test.py</span>

```py
from main import *

run_cases = [
    (1, 200, 300),
    (2, 50, 250),
]

submit_cases = run_cases + [
    (0, 0, 0),
    (0, 200, 200),
    (176, 350, 17950),
    (250, 100, 25100),
]


def test(input1, input2, expected_output):
    print("---------------------------------")
    print(f"Inputs: {input1}, {input2}")
    print(f"Expected:  {expected_output}")
    result = total_xp(input1, input2)
    print(f"Actual: {result}")
    if result == expected_output:
        print("Pass")
        return True
    print("Fail")
    return False


def main():
    passed = 0
    failed = 0
    skipped = len(submit_cases) - len(test_cases)
    for test_case in test_cases:
        correct = test(*test_case)
        if correct:
            passed += 1
        else:
            failed += 1
    if failed == 0:
        print("============= PASS ==============")
    else:
        print("============= FAIL ==============")
    if skipped > 0:
        print(f"{passed} passed, {failed} failed, {skipped} skipped")
    else:
        print(f"{passed} passed, {failed} failed")


test_cases = submit_cases
if "__RUN__" in globals():
    test_cases = run_cases

main()
```

> **✔️ Pass!**




### ▶️ L2: Two Lesson Types


The two types of coding lessons on Boot.dev are:

- console output lessons
- unit-test lessons


#### Console Output Lessons

- Only 1 file of code, usually with a comment explaining where to write your code
- When you "submit" your code, its console output **must match the expected output exactly to pass**
- 🚨 Debug `print` statements will cause your code to fail submission, so remove them before submitting

#### Unit-Test Lessons

- 2 files of code: `main` and `main_test`. You can read the tests but you can't edit them
- When you "submit" your code, **the return values of your functions must match the expected values exactly** to pass
- **Console output is ignored**, you can leave debug print statements in your code



### ▶️ L3: Debugging



<span class="boot-dev-op">Debugging - Run vs. Submit:</span>

<section class="boot-dev-op-sec">

When you're working as a professional developer, you'll typically write code on your computer and test it by yourself before it's deployed to users.

That first part of the process is called _debugging_. You write some code, run it, and if it doesn't work, you fix the bugs. You repeat this process until you're confident that your code works as expected.

#### Run vs. Submit

At Boot.dev, the `Run` button is for debugging. The `Submit` button mimics the idea of publishing your code for production use.

You should be debugging your code using the `Run` button. You should be adding `print()` statements to your code to make sure it's doing what you think it's doing at different points in the code.

- Write a line to calculate a value
- `print()` the value you calculated
- Run the code
- Did it print what you expected? If not, fix it
- Repeat


**You will never lose XP or be penalized on Boot.dev for using the run button**. However, there are 🚨 consequences for submitting broken code, (_just like there are career consequences for pushing broken code to your users!_)

#### The Submit Button Will Run Additional Tests

When you use the `Run` button, a few tests will run against your code. However, the `Submit` button will run _**additional tests that you're not able to debug against**_. That's what keeps it **fun** and **realistic** (it's so hard to know what your users will do with your code!).

</section>



<section class="info-banner"><span>💡 PRO TIP: </span>

You should be adding `print()` statements to your code and debugging your code using the `Run` button.

</section>

### ▶️ L4: Learning Effectively


<span class="boot-dev-op">Learning Effectively - How to Solve Hard Coding Problems:</span>

<section class="boot-dev-op-sec">

#### ⚡ This course is **about to get a bit harder**.

 There's no way around it, if programming were a walk in the park everyone would be earning 6 figures as a software engineer. But it's not, and to succeed without getting stuck and frustrated, you need to learn how to learn.

#### Process for Solving Hard Coding Problems

1. **Read the lesson first!** Figure out the examples before writing your own code.
1. **Read the assignment.** Understand the goal of the assignment before you start writing code.
1. **Start writing code.**
1. **Add print() statements.** Don't wait until you've written a lot of code to start testing. Add `print()` statements and use the `Run` button to see if your code is doing what you expect at each step. It's easier to find issues in small bits of code than in large blocks of code.
   - Keep running, printing, and fixing until you're confident your code is working.
1. **Submit your code.** If the assignment you're working on has unit tests, no need to remove your debugging `print()` statements. If the assignment you're working on is testing console output, be sure to remove your `print()` statements before submitting.
1. **Compare your code to the instructor's.** You will not be penalized for looking at the solution after you have successfully completed the assignment.

#### Additional Tidbits

- **Try to use Boots before peeking at the solution.** Boots is quite good at giving you pointed hints to help you solve the problem on your own.
-  **It's okay to peek at the solution when you're completely stuck every once in a while**, but **don't make it a habit!** If you find that you're always stuck, you should restart the **chapter** or **course** to make sure you understand the material.
-  You can **reset your code for an assignment** with the "reset" `↶` button. For example, maybe you forgot which modifications you made vs which code was left by the instructor.
-  You can **reset all your cached code from the settings page**. This is useful if you want to restart a course or chapter.

</section>




<section class="info-banner"><span>💡 PRO TIP: </span>

If you find that you're always stuck, you should **restart the chapter or course to make sure you understand the material.**

</section>


<section class="info-banner"><span>💡 PRO TIP: </span>

When you are stuck always **ask Boots first!**

</section>


### ▶️ L5: Learning Effectively



### ▶️ L6: Learning Effectively



### ▶️ L7: Debugging Practice


<section class="callout"><span class="label-verbatim">Debugging Practice 👇🏽</span>


I want to walk you through how I approach writing code, complete with all the debugging steps I take along the way.

The goal is to write **_small amounts of code_**, and then test each bit of code to make sure it's doing what we expect before moving on. **Trying to write entire programs at once is a recipe for pain and suffering.** The goal is to write a few lines, test them, and then write a few more lines, and repeat until you're done.

This isn't a technique that's unique to beginners. Even senior engineers write code this way.

#### Assignment
Let's complete the `unlock_achievement` function. It accepts 3 arguments:

- `before_xp`: int
- `ach_xp`: int
- `ach_name`: str

It should return 2 values:

- The player's xp after the achievement is unlocked (The sum of `before_xp` and `ach_xp`)
- An alert message that says `"Achievement Unlocked: ACHIEVEMENT_NAME"`, where `ACHIEVEMENT_NAME` is the name of the achievement

Let's start by running the code in its current state. You should see an error like this:

### Error Section

<section class="error-banner">Error:

```sh
IndentationError: expected an indented block after function definition
```

</section>

Hmm... looks like we're getting a syntax error: _**Python doesn't allow you to have an empty function body**_. To get past this error, let's just return two dummy values from the function:

```py
def unlock_achievement(before_xp, ach_xp, ach_name):
    return None, None
```

Run the code again. This time you shouldn't get a syntax error, but your tests should fail because you're returning the incorrect values. Let's fix that.

Let's start by calculating the new amount of xp. Update the function body:

```py
def unlock_achievement(before_xp, ach_xp, ach_name):
    after_xp = before_xp - ach_xp
    print("After xp:", after_xp)
    return None, None
```

Run the code again. This time you should see the `after_xp` value printed to the console. Does it look correct? It shouldn't... we have a bug! The `after_xp` should be the sum of the `before_xp` and `ach_xp` values. Fix the code and run it again to make sure it's working.

Once that's working, remove the `print` statement and `return` the `after_xp` value instead of the first `None`. Run the code again. You should see that your tests are closer: The first "expected" and "actual" values should match for each test. The second return value is still broken, let's fix it!

Now that we have the `after_xp` value, we need to create an alert message. Update the function body:

```py
def unlock_achievement(before_xp, ach_xp, ach_name):
    after_xp = before_xp + ach_xp
    alert = "Achievement: " + ach_name
    print(alert)
    return after_xp, None
```

Run the code. Is the console output what you expect? We want the alert to say:

```sh
Achievement Unlocked: ACHIEVEMENT_NAME
```
Looks like the output is missing the word "Unlocked". Fix the bug, then run the code again to make sure it's working.

When you're confident, remove the `print` statement and `return` the `alert` value instead of the second `None`. Run the code again. You should see that your tests are passing!

Now that your tests are passing, submit your code so that it runs against _all_ the test cases. Remember, when you "run" instead of submit you're only able to see a few of the tests. The submit button will run _all_ the tests, **which might catch bugs you didn't know you had!** That's why it's important to debug with print statements and the run button before submitting.



</section>

<br>

<section class="info-banner"><span>💡 PRO TIP: </span>

Use the **Run** button and debug with print statements first—**Submit** runs **all tests**, and hidden bugs can sneak through!

</section>


### ▶️ L8: Stack Trace

- **stack trace** (aka **traceback**): A detailed, multi-line breadcrumb trail of function calls and file locations showing where Python tripped up, helping you pinpoint the exact line and cause of an error.

**Example:**

<section class="error-banner">Error:

```py
PythonError: Traceback (most recent call last):
  File "<exec>", line 17, in <module>
  File "<string>", line 1, in <module>
  File "/home/pyodide/main.py", line 3
    msg = f"You have {strength} strength, {wisdom} wisdom, and {dexterity} dexterity for a total of {total} stats.
                                                                                                                  ^
IndentationError: unindent does not match any outer indentation level
```

</section>


<span class="boot-dev-op">How to Read a Stack Trace:</span>

<section class="boot-dev-op-sec">


1. `PythonError: Traceback (most recent call last):`

This is a **standard header** that's just letting us know that a Python traceback is what we're looking at.

2. `File "<exec>", line 17, in <module>` and `File "<string>", line 1, in <module>`

This is the start of the "trace". These strange `"<exec>"` and `"<string>"` files **don't really exist**, the Python interpreter is letting us know about them because they have to do with how your code is executed in a virtual browser-based environment.

3. `File "/home/pyodide/main.py", line 3`

Now we're getting to the real meat of the error message! The purpose of a "trace" is to show us the path that the Python interpreter took through our code before it encountered the error, which can help us figure out what went wrong.

In this case, the interpreter was executing the code in the `main.py` file, and it got to line 3 before it encountered the error.

4. `msg = f"You have {strength} strength, {wisdom} wisdom, and {dexterity} dexterity for a total of {total} stats.`

This is the line of code that caused the error.

5. `IndentationError: unindent does not match any outer indentation level`

This is the type of error that was raised. In this case, it's an `IndentationError`, which means that **the Python interpreter was expecting a certain amount of indentation** (whitespace at the beginning of the line) but it didn't get what it was expecting.

**Don't be fooled!** The proper amount of indentation in Python is 4 spaces (or one <tab> stroke). In this case, line 2 is actually indented 6 spaces, which is why the interpreter is confused. Fix line 2.

</section>

<br>


<section class="info-banner"><span>💡 PRO TIP: </span>

The proper amount of indentation in Python is **4 spaces**

</section>

<br>

- **indentation error**: when the Python interpreter expects a specific amount of indentation (usually 4 spaces or a tab) but finds something different, breaking the code’s structure.




























<!-- END Lesson Notes -->

---


## References

- N/A

